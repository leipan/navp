\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{soul}
\usepackage{flushend}
% \usepackage[aboveskip=0pt,font=small]{caption}

% personal commands
\newcommand{\comment}[1]{{\color{red}\textit{#1}}}
\newcommand{\TODO}[1]{{\color{blue}\textit{#1}}}
% \def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
%     T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Transparent C/R for Navigational Programming and Fault Tolerance in Science Data Systems}

% Commenting out for the double blind submission

\author{\IEEEauthorblockN{Lei Pan}
\IEEEauthorblockA{\textit{Jet Propulsion Laboratory}} \\
Pasadena, USA\\
lei.pan@jpl.nasa.gov\\
\and
\IEEEauthorblockN{Twinkle Jain}
\IEEEauthorblockA{\textit{Northeastern University}} \\
Boston, USA\\
jain.t@northeastern.edu}

\maketitle

\begin{abstract}
We apply checkpointing to science data systems. With program state migration, we enable Navigational Programming and fault tolerance. This paper describes high level designs and initial implementations.
\end{abstract}

\begin{IEEEkeywords}
Navigational Programming (NavP), fault-tolerant computing (FTC), DMTCP, science data systems (SDS)
\end{IEEEkeywords}
\vspace{-2.2mm}
\section{Introduction}
\label{sec:introduction}
In the currently available science data systems (SDS), there are two problems that are not properly addressed: (1) Long running tasks are not readily breakable into smaller ones to leverage the Amazon EC2 Spot market, which provides steep discounts; and (2) Only embarrassingly parallel algorithms (e.g., MapReduce) are easily programmable. Furthermore, scientist programmers cannot deploy their apps without the help from SDS experts.

We will leverage checkpointing and restart (C/R) to enable Navigational Programming (NavP) and achieve fault-tolerant computing (FTC) to facilitate high performance, effective resource leveraging, and ease of use for scientist programmers.

\section{FTC, NavP, and DMTCP}
\label{sec:s1}
We introduce several concepts involved in this paper.

\subsection{FTC in the Cloud}
\label{subsec:s11}

Amazon provides EC2 Spot Instances, which are spare compute capacity in the AWS Cloud available at steep discounts (90\% savings) but they can be taken away at any time. In the meanwhile each atomic task can take hours to finish. Our strategy is to break the original tasks into smaller pieces using checkpointing and introduce FTC, so the ``remaining'' computation can be brought to and restarted on a new instance after the old instance disappears.

\subsection{NavP}
\label{subsec:s12}

The distributed parallel system is not directly programmable by scientist programmers. One would always have to work with an SDS expert in virtualizing and deploying the app level programs, even between version updates. The levels of abstractions for different concerns, algorithm vs. details of distribution, are mixed, and therefore unnecessary burdens are put on the app developers’ shoulders. For applications that are not by nature embarrassingly parallel, this task is extremely difficult if not impossible. NavP was introduced to address these difficulties~\cite{pan2004navp}. A new view of distributed programming, namely the NavP view is introduced. In this view, the description of a computation follows its locus. This is done by inserting  hop() statements in the original sequential code. A hop(dest) statement pauses the computation, collects all the program/thread state, migrates to the dest node, and resumes computation.

\subsection{DMTCP}
\label{subsec:s13}

We will leverage the DMTCP system (Distributed MultiThreaded CheckPointing)~\cite{ansel2009dmtcp}. DMTCP transparently checkpoints computations in user space. It saves a copy of the program state to disk (called a checkpoint memory image (CMI)) and resumes the process later wherever the CMI goes. It requires no modifications to user application code nor to the OS kernel.

The next section describes how to enable hop() and FTC using dmtcp plugins and web services to move program state.


\section{The NavP Bridging Services (NBS) to enable NavP and FTC}
\label{sec:s2}

\subsection{The NavP Bridging Services (NBS)}
\label{subsec:s21}

The DMTCP plugins provide a flexible way to introduce add-on behaviors around DMTCP events~\cite{ansel2009dmtcp}. They wrap custom code around DMTCP calls. The NavP Bridging Services (NBS) run on each and every compute node and serve the client requests from the app processes. For example, an app process running on Host A can call a dmtcp.hop(B) plugin, which in turn calls DMTCP checkpoint() generating the CMI as well as the DMTCP restart script, and then call the svc/hop service running on Host B before it terminates itself. The hop service on Host B in turn copies the CMI and restart script from Host A to B, and runs the restart script to resume the computation. This is how process migration is implemented.

\subsection{NBS to enable NavP}
\label{subsec:s22}

We use a plugin named $\mathtt{dmtcp.hop(dest)}$ and a service named $\mathtt{svc/hop}$ to enable NavP. 
Pseudocode for $\mathtt{dmtcp.hop()}$ in Figure~\ref{code:dmtcp_hop}, in which S3 means some shared disk volume either 
in an S3 bucket or bound to the containers.

\begin{figure}[!ht]
\vspace{0.3in}
\begin{center}
%%% \begin{minipage}{1.5in}
\begin{center}
\mbox{\input{code_dmtcp_hop.tex}}\\[0.3em]
\end{center}
%%% \end{minipage}%
\hspace{\fill}%
\caption{Pseudocode for the dmtcp.hop() plugin.}
\label{code:dmtcp_hop}
\end{center}
\end{figure}


\begin{figure}[!ht]
\vspace{0.3in}
\begin{center}
%%% \begin{minipage}{1.5in}
\begin{center}
\mbox{\input{code_hop_service.tex}}\\[0.3em]
\end{center}
%%% \end{minipage}%
\hspace{\fill}%
\caption{Pseudocode for the svc/hop service.}
\label{code:svc_hop}
\end{center}
\end{figure}


\subsection{NBS to enable FTC in SDS}
\label{subsec:s23}

When jobs in SDS are treated as atomic operations, they can be either ``new'' before the run, or ``finished'' after the run. Any interrupted jobs return to the ``new'' status. A new job has input datasets, and a finished job has products. For sake of discussion, we ignore more sophisticated situations, such as a ``running'' status, in which a job can have both input datasets and partial products. These additional combinations can be handled in real life applications with the same principle.

We implement three services in NBS to handle jobs:  (1) $\mathtt{svc/list\_jobs}$: it returns all jobs with their job\_ids along with their statuses, such as those shown in Fig~\ref{code:jobs}:

\begin{figure}[!ht]
\vspace{0.3in}
\begin{center}
%%% \begin{minipage}{1.5in}
\begin{center}
\mbox{\input{code_jobs.tex}}\\[0.3em]
\end{center}
%%% \end{minipage}%
\hspace{\fill}%
\caption{Sample list of jobs.}
\label{code:jobs}
\end{center}
\end{figure}

(2) $\mathtt{svc/get\_job}$: it returns the status of a job given its job\_id, or the next job that is not finished when no job\_id is provided; and (3) $\mathtt{svc/publish\_job}$: it publishes jobs with two possible statuses: ``ckpt,'' in which case the CMI and restart script are uploaded, and “finished,” in which case the final product is uploaded.



\begin{figure}[!ht]
\vspace{0.3in}
\begin{center}
%%% \begin{minipage}{1.5in}
\begin{center}
\mbox{\input{code_app.tex}}\\[0.3em]
\end{center}
%%% \end{minipage}%
\hspace{\fill}%
\caption{Pseudocode for JPL real application of co-location.}
\label{code:jobs}
\end{center}
\end{figure}



\section{Conclusion}
\label{sec:conclusion}


\IEEEtriggeratref{6}
\bibliographystyle{IEEEtran}
\bibliography{supercheck-sc}

\end{document}

